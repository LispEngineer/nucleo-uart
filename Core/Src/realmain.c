/*
 * realmain.c
 * Since the main.c is auto-generated by STM32CubeIDE
 * this is the real "main" file for stuff that is not
 * auto-generated.
 *
 *  Created on: Aug 25, 2024
 *      Author: Douglas P. Fields, Jr.
 *   Copyright: 2024, Douglas P. Fields, Jr.
 *     License: Apache 2.0
 */

#include <stdio.h>
#include <stdlib.h>
#include "stm32f7xx_hal.h"
#include "stm32f7xx_ll_usart.h"
#include "string.h" // STM32 Core
#include "main.h"
#include "realmain.h"
#include "ringbuffer.h"


#define WELCOME_MSG "Welcome to the Nucleo management console v4\r\n"
#define MAIN_MENU   "Select the option you are interested in:\r\n\t1. Toggle LD1 Green LED\r\n\t2. Read USER BUTTON status\r\n\t3. Clear screen and print this message\r\n\t4. Print counters"
#define PROMPT "\r\n> "
#define NOTE_ON  "\x90\x3C\x40"
#define NOTE_OFF "\x80\x3C\x40"

// From main.c
extern UART_HandleTypeDef huart3;
extern UART_HandleTypeDef huart6;

static uint32_t overrun_errors = 0;
static uint32_t uart_error_callbacks = 0;
static uint32_t usart3_interrupts = 0;
static uint32_t midi_overrun_errors = 0;

// I/O buffers: Serial and MIDI, in & out
char s_i_buff[16];
ring_buffer_t s_i_rb;
char m_i_buff[16];
ring_buffer_t m_i_rb;
char s_o_buff[128];
ring_buffer_t s_o_rb;
char m_o_buff[32];
ring_buffer_t m_o_rb;

/** Set up all our i/o buffers */
void init_ring_buffers() {
  ring_buffer_init(&s_i_rb, s_i_buff, sizeof(s_i_buff));
  ring_buffer_init(&s_o_rb, s_o_buff, sizeof(s_o_buff));
  ring_buffer_init(&m_i_rb, m_i_buff, sizeof(m_i_buff));
  ring_buffer_init(&m_o_rb, m_o_buff, sizeof(m_o_buff));
}

/** If there is input ready, pull it into our input buffers.
 * If there is output waiting, send it when possible.
 * If the input buffers are full, increase counters.
 */
void check_io() {
  char c;

  // Check for serial output waiting to go
  if (ring_buffer_num_items(&s_o_rb) > 0) {
    // Check if we can send the item now
    if (LL_USART_IsActiveFlag_TXE(huart3.Instance)) {
      ring_buffer_dequeue(&s_o_rb, &c);
      LL_USART_TransmitData8(huart3.Instance, c);
    }
  }
}

/** Queues data to be sent over our serial output. */
void serial_transmit(const uint8_t *msg, uint16_t size) {
  // TODO: Check for send buffer overflow
  ring_buffer_queue_arr(&s_o_rb, (const char *)msg, (ring_buffer_size_t)size);
}

void printWelcomeMessage(void) {
  /*
  HAL_UART_Transmit(&huart3, (uint8_t*)"\033[0;0H", strlen("\033[0;0H"), HAL_MAX_DELAY);
  HAL_UART_Transmit(&huart3, (uint8_t*)"\033[2J", strlen("\033[2J"), HAL_MAX_DELAY);
  */
  HAL_UART_Transmit(&huart3, (uint8_t*)"\r\n\r\n", strlen("\r\n\r\n"), HAL_MAX_DELAY);
  HAL_UART_Transmit(&huart3, (uint8_t*)WELCOME_MSG, strlen(WELCOME_MSG), HAL_MAX_DELAY);
  HAL_UART_Transmit(&huart3, (uint8_t*)MAIN_MENU, strlen(MAIN_MENU), HAL_MAX_DELAY);
}

uint8_t readUserInput(void) {
  char readBuf[1];
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  // Not all #ifdefs use this variable, but all set it.
  HAL_StatusTypeDef retval;
#pragma GCC diagnostic pop

  HAL_UART_Transmit(&huart3, (uint8_t*)PROMPT, strlen(PROMPT), HAL_MAX_DELAY);

  retval = HAL_UART_Receive(&huart3, (uint8_t*)readBuf, 1, HAL_MAX_DELAY);

  return atoi(readBuf);
}


/* Just quickly send a midi note on and then off */
void send_midi_note_on_off(void) {
  const uint32_t delay = 25; // lower causes less likely overrun errors (e.g., 20)
  HAL_UART_Transmit(&huart6, (uint8_t *)NOTE_ON, 3, HAL_MAX_DELAY);
  HAL_Delay(delay);
  HAL_UART_Transmit(&huart6, (uint8_t *)NOTE_OFF, 3, HAL_MAX_DELAY);
}

uint8_t processUserInput(uint8_t opt) {
  if (opt == 0) {
    return 0;
  }

  char msg[40];

  send_midi_note_on_off();

  snprintf(msg, sizeof(msg), "%d", opt);
  HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

  switch (opt) {
  case 1:
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);
    break;
  case 2:
    snprintf(msg, sizeof(msg), "\r\nUSER BUTTON status: %s",
              HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) != GPIO_PIN_RESET ? "PRESSED" : "RELEASED");
    HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
    break;
  case 3:
    return 2;
  case 4:
    snprintf(msg, sizeof(msg) - 1, "\r\nUA3I: %lu, ORE: %lu, MIDI_ORE: %lu\r\n",
              usart3_interrupts, overrun_errors, midi_overrun_errors);
    HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
    break;
  default:
    return 0;
  }

  return 1;
}

/**
 * Returns 0-255 when byte received.
 * Returns 256+ when no byte received.
 */
uint16_t read_midi(void) {
  // If we're not using interrupts: LL_USART_ClearFlag_ORE
  // Overrun interrupt is not being called and hence overrun flag is not
  // being cleared.

  // Check if a read is ready
  if (!LL_USART_IsActiveFlag_RXNE(huart6.Instance)) {
    return (uint16_t)257U;
  }

  return (uint16_t)LL_USART_ReceiveData8(huart6.Instance);
}

/**
 * Processes a received MIDI byte.
 * For now, just print it (which will certainly lead to overrun).
 */
void process_midi(uint8_t midi_byte) {
  char msg[30];
  snprintf(msg, sizeof(msg) - 1, "\r\nMIDI: %02X\r\n", midi_byte);
  HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);
}

void realmain() {
  uint16_t opt = 0;
  uint32_t last_overrun_errors = overrun_errors;
  uint32_t last_usart3_interrupts = usart3_interrupts;
  char msg[36];
  uint16_t midi_in = 0;

  init_ring_buffers();

  printMessage:
  printWelcomeMessage();

  while (1) {
    opt = readUserInput();
    processUserInput(opt);

    midi_in = read_midi();
    if (midi_in <= 255) {
      process_midi((uint8_t)midi_in);
    }

    if (overrun_errors != last_overrun_errors) {
      snprintf(msg, sizeof(msg) - 1, "\r\nORE: %lu\r\n", overrun_errors);
      last_overrun_errors = overrun_errors;
      HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);
    }
    if (usart3_interrupts != last_usart3_interrupts) {
      snprintf(msg, sizeof(msg) - 1, "\r\nUA3I: %lu\r\n", usart3_interrupts);
      last_usart3_interrupts = usart3_interrupts;
      HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);
    }

    if (opt == 3) {
      goto printMessage;
    }
  }
} // realmain()



////////////////////////////////////////////////////////////////////////////////////////
// Callbacks


void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
  // We just want to clear an overrun error and acknowledge it happened.
  // SEE: https://electronics.stackexchange.com/questions/376104/smt32-hal-uart-crash-on-possible-overrun
  // SEE: https://github.com/micropython/micropython/issues/3375


  if (huart == &huart3) {
    // Serial terminal via ST-Link
    usart3_interrupts++;

    // The earlier code will have set the HAL_UART_ERROR_ORE flag IF an OverRunError happened.
    // See the code commented: UART Over-Run interrupt occurred

    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
      uart_error_callbacks++;
    }

  } else if (huart == &huart6) {
    // MIDI
    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
      midi_overrun_errors++;
    }
    // midi_overrun_errors++;
  }
  // Re-enable the interrupts (not sure if this is necessary)
  // This did not work when in the "if" above (it never got invoked).
  __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
}

