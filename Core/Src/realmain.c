/*
 * realmain.c
 * Since the main.c is auto-generated by STM32CubeIDE
 * this is the real "main" file for stuff that is not
 * auto-generated.
 *
 *  Created on: Aug 25, 2024
 *      Author: Douglas P. Fields, Jr.
 *   Copyright: 2024, Douglas P. Fields, Jr.
 *     License: Apache 2.0
 */

#include <stdio.h>
#include <stdlib.h>
#include "stm32f7xx_hal.h"
#include "string.h" // STM32 Core
#include "main.h"
#include "realmain.h"


#define WELCOME_MSG "Welcome to the Nucleo management console v2\r\n"
#define MAIN_MENU   "Select the option you are interested in:\r\n\t1. Toggle LD1 Green LED\r\n\t2. Read USER BUTTON status\r\n\t3. Clear screen and print this message "
#define PROMPT "\r\n> "
#define NOTE_ON  "\x90\x3C\x40"
#define NOTE_OFF "\x80\x3C\x40"

// From main.c
extern UART_HandleTypeDef huart3;
extern UART_HandleTypeDef huart6;

void printWelcomeMessage(void) {
  HAL_UART_Transmit(&huart3, (uint8_t*)"\033[0;0H", strlen("\033[0;0H"), HAL_MAX_DELAY);
  HAL_UART_Transmit(&huart3, (uint8_t*)"\033[2J", strlen("\033[2J"), HAL_MAX_DELAY);
  HAL_UART_Transmit(&huart3, (uint8_t*)WELCOME_MSG, strlen(WELCOME_MSG), HAL_MAX_DELAY);
  HAL_UART_Transmit(&huart3, (uint8_t*)MAIN_MENU, strlen(MAIN_MENU), HAL_MAX_DELAY);
}

uint8_t readUserInput(void) {
  char readBuf[1];
  HAL_StatusTypeDef retval;

  HAL_UART_Transmit(&huart3, (uint8_t*)PROMPT, strlen(PROMPT), HAL_MAX_DELAY);

#ifdef DO_UART_RECEIVE_TIMEOUTS
  // A low number makes it "work" (~50)
  // A high number is good for debugging (~10000)
  const uint32_t timeout = 10000; // Milliseconds (or timer ticks)

  do {
    retval = HAL_UART_Receive(&huart3, (uint8_t*)readBuf, 1, timeout);
    if (retval == HAL_TIMEOUT) {
      // This is here solely to enable a breakpoint on timeout.
      (*readBuf)++; // Increment the readBuf pointlessly, hopefully will not be optimized away
    }
  } while (retval == HAL_TIMEOUT);
#else
  retval = HAL_UART_Receive(&huart3, (uint8_t*)readBuf, 1, HAL_MAX_DELAY);
#endif // DO_UART_RECEIVE_TIMEOUTS

  return atoi(readBuf);
}


/* Just quickly send a midi note on and then off */
void send_midi_note_on_off(void) {
  const uint32_t delay = 20;
  HAL_UART_Transmit(&huart6, (uint8_t *)NOTE_ON, 3, HAL_MAX_DELAY);
  HAL_Delay(delay);
  HAL_UART_Transmit(&huart6, (uint8_t *)NOTE_OFF, 3, HAL_MAX_DELAY);
}

uint8_t processUserInput(uint8_t opt) {
  char msg[30];

  send_midi_note_on_off();

  if (!opt || opt > 3)
    return 0;

  sprintf(msg, "%d", opt);
  HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

  switch (opt) {
  case 1:
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);
    break;
  case 2:
    sprintf(msg, "\r\nUSER BUTTON status: %s", HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) != GPIO_PIN_RESET ? "PRESSED" : "RELEASED");
    HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
    break;
  case 3:
    return 2;
  };

  return 1;
}

void realmain() {
  uint8_t opt = 0;

  printMessage:
  printWelcomeMessage();

  while (1) {
    opt = readUserInput();
    processUserInput(opt);
    if (opt == 3) {
      goto printMessage;
    }
  }
} // realmain()



////////////////////////////////////////////////////////////////////////////////////////
// Callbacks

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
  // We just want to clear an overrun error and acknowledge it happened.
  // SEE: https://electronics.stackexchange.com/questions/376104/smt32-hal-uart-crash-on-possible-overrun
  // SEE: https://github.com/micropython/micropython/issues/3375
  uint32_t isrflags = READ_REG(huart->Instance->ISR);

  if( ((isrflags & USART_ISR_ORE) != RESET) && ((isrflags & USART_ISR_RXNE) == RESET) ) {
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
    huart->ErrorCode |= HAL_UART_ERROR_ORE;
    return;
  }
}
