/*
 * realmain.c
 * Since the main.c is auto-generated by STM32CubeIDE
 * this is the real "main" file for stuff that is not
 * auto-generated.
 *
 *  Created on: 2024-08-25
 *  Updated on: 2024-09-08
 *      Author: Douglas P. Fields, Jr.
 *   Copyright: 2024, Douglas P. Fields, Jr.
 *     License: Apache 2.0
 */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include "stm32f7xx_hal.h"
#include "stm32f7xx_ll_usart.h"
#include "string.h" // STM32 Core
#include "main.h"
#include "realmain.h"
#include "ringbuffer.h"
#include "midi.h"
#include "tonegen.h"

#define FAST_BSS __attribute((section(".fast_bss")))
#define FAST_DATA __attribute((section(".fast_data")))

#define WELCOME_MSG "Nucleo MIDI console v5\r\n"
#define MAIN_MENU   "Options:\r\n" \
                     "\t1. Toggle LD1 Green LED\r\n" \
                     "\t2. Read USER BUTTON status\r\n" \
                     "\t3. Send MIDI note on/off\r\n" \
                     "\t4. Print counters\r\n" \
                     "\t5. Next tone value\r\n" \
                     "\t6. Sound tone\r\n" \
                     "\t(. Use all mem\r\n" \
                     "\t). Stack overflow\r\n" \
                     "\t~. Print this message"
#define PROMPT "\r\n> "
#define NOTE_ON_START  "\x90\x3C\x40"
#define NOTE_OFF_START "\x80\x3C\x40"

uint8_t NOTE_ON[] = NOTE_ON_START;
uint8_t NOTE_OFF[] = NOTE_OFF_START;

// From main.c
extern UART_HandleTypeDef huart3;
extern UART_HandleTypeDef huart6;
extern I2S_HandleTypeDef hi2s3;

static uint32_t overrun_errors = 0;
static uint32_t uart_error_callbacks = 0;
static uint32_t usart3_interrupts = 0;
static uint32_t midi_overrun_errors = 0;
static uint32_t loops_per_tick;

// I/O buffers: Serial and MIDI, in & out
FAST_BSS char s_i_buff[16];
FAST_BSS ring_buffer_t s_i_rb;
FAST_BSS char m_i_buff[16];
FAST_BSS ring_buffer_t m_i_rb;
FAST_BSS char s_o_buff[256];
FAST_BSS ring_buffer_t s_o_rb;
FAST_BSS char m_o_buff[32];
FAST_BSS ring_buffer_t m_o_rb;

// MIDI input parsers
FAST_BSS midi_stream midi_stream_0;

// Test Fast Data
FAST_DATA char test_fast_string[] = "This is a fast string test.";
FAST_DATA size_t tfs_len = sizeof(test_fast_string) - 1;

// Tone Generator
FAST_DATA tonegen_state tonegen1;


// See: http://elastic-notes.blogspot.com/2020/11/use-pcm5102-with-stm32_76.html
const uint16_t old_triangle_wave[]  = {
  0x400,0x800,0xc00,0x1000,0x1400,0x1800,0x1c00,0x2000,
  0x2400,0x2800,0x2c00,0x3000,0x3400,0x3800,0x3c00,0x4000,
  0x4400,0x4800,0x4c00,0x5000,0x5400,0x5800,0x5c00,0x6000,
  0x6400,0x6800,0x6c00,0x7000,0x7400,0x7800,0x7c00,0x8000,
  0x83ff,0x87ff,0x8bff,0x8fff,0x93ff,0x97ff,0x9bff,0x9fff,
  0xa3ff,0xa7ff,0xabff,0xafff,0xb3ff,0xb7ff,0xbbff,0xbfff,
  0xc3ff,0xc7ff,0xcbff,0xcfff,0xd3ff,0xd7ff,0xdbff,0xdfff,
  0xe3ff,0xe7ff,0xebff,0xefff,0xf3ff,0xf7ff,0xfbff,0xffff,
  0xfbff,0xf7ff,0xf3ff,0xefff,0xebff,0xe7ff,0xe3ff,0xdfff,
  0xdbff,0xd7ff,0xd3ff,0xcfff,0xcbff,0xc7ff,0xc3ff,0xbfff,
  0xbbff,0xb7ff,0xb3ff,0xafff,0xabff,0xa7ff,0xa3ff,0x9fff,
  0x9bff,0x97ff,0x93ff,0x8fff,0x8bff,0x87ff,0x83ff,0x8000,
  0x7c00,0x7800,0x7400,0x7000,0x6c00,0x6800,0x6400,0x6000,
  0x5c00,0x5800,0x5400,0x5000,0x4c00,0x4800,0x4400,0x4000,
  0x3c00,0x3800,0x3400,0x3000,0x2c00,0x2800,0x2400,0x2000,
  0x1c00,0x1800,0x1400,0x1000,0xc00,0x800,0x400,0x0,
};

// 8 x 8 - At 32kHz this is 64
const int16_t mono_triangle_wave[] = {
    -32000,
    -31000,
    -30000,
    -29000,
    -28000,
    -27000,
    -26000,
    -25000,
    -24000,
    -23000,
    -22000,
    -21000,
    -20000,
    -19000,
    -18000,
    -17000,
    -16000,
    -15000,
    -14000,
    -13000,
    -12000,
    -11000,
    -10000,
    -9000,
    -8000,
    -7000,
    -6000,
    -5000,
    -4000,
    -3000,
    -2000,
    -1000,
    0,
    1000,
    2000,
    3000,
    4000,
    5000,
    6000,
    7000,
    8000,
    9000,
    10000,
    11000,
    12000,
    13000,
    14000,
    15000,
    16000,
    17000,
    18000,
    19000,
    20000,
    21000,
    22000,
    23000,
    24000,
    25000,
    26000,
    27000,
    28000,
    29000,
    30000,
    31000,
    32000,
};

// 8x8 stereo triangle wave - 64 samples / 2 = 32
// at 32kHz sample rate this will now be 1kHz audio.
const int16_t triangle_wave[] = {
    -32000,
    -32000,
    -30000,
    -30000,
    -28000,
    -28000,
    -26000,
    -26000,
    -24000,
    -24000,
    -22000,
    -22000,
    -20000,
    -20000,
    -18000,
    -18000,
    -16000,
    -16000,
    -14000,
    -14000,
    -12000,
    -12000,
    -10000,
    -10000,
    -8000,
    -8000,
    -6000,
    -6000,
    -4000,
    -4000,
    -2000,
    -2000,
    0,
    0,
    2000,
    2000,
    4000,
    4000,
    6000,
    6000,
    8000,
    8000,
    10000,
    10000,
    12000,
    12000,
    14000,
    14000,
    16000,
    16000,
    18000,
    18000,
    20000,
    20000,
    22000,
    22000,
    24000,
    24000,
    26000,
    26000,
    28000,
    28000,
    30000,
    30000,
};

/** Set up all our i/o buffers */
void init_ring_buffers() {
  ring_buffer_init(&s_i_rb, s_i_buff, sizeof(s_i_buff));
  ring_buffer_init(&s_o_rb, s_o_buff, sizeof(s_o_buff));
  ring_buffer_init(&m_i_rb, m_i_buff, sizeof(m_i_buff));
  ring_buffer_init(&m_o_rb, m_o_buff, sizeof(m_o_buff));
}

/** initialize our MIDI parsers */
void init_midi_buffers() {
  midi_stream_init(&midi_stream_0);
}

/** Read any waiting input from this USART and stick it in the
 * input ring_buffer. Write any output to the USART if it is ready.
 */
void check_uart(USART_TypeDef *usart, ring_buffer_t *in_rb, ring_buffer_t *out_rb) {
  char c;

  // Check for serial output waiting to go
  if (ring_buffer_num_items(out_rb) > 0) {
    // Check if we can send the item now
    if (LL_USART_IsActiveFlag_TXE(usart)) {
      ring_buffer_dequeue(out_rb, &c);
      LL_USART_TransmitData8(usart, c);
    }
  }

  // Check for serial input waiting to be read
  if (LL_USART_IsActiveFlag_RXNE(usart)) {
    c = LL_USART_ReceiveData8(usart);
    ring_buffer_queue(in_rb, c);
  }
}

/** If there is input ready, pull it into our input buffers.
 * If there is output waiting, send it when possible.
 * If the input buffers are full, increase counters.
 */
void check_io() {
  // Serial port
  check_uart(huart3.Instance, &s_i_rb, &s_o_rb);
  // MIDI port
  check_uart(huart6.Instance, &m_i_rb, &m_o_rb);
}

/** Queues data to be sent over our serial output. */
void serial_transmit(const uint8_t *msg, uint16_t size) {
  // TODO: Check for send buffer overflow
  ring_buffer_queue_arr(&s_o_rb, (const char *)msg, (ring_buffer_size_t)size);
}

/** Queues data to be sent over our serial output. */
void midi_transmit(const uint8_t *msg, uint16_t size) {
  // TODO: Check for send buffer overflow
  ring_buffer_queue_arr(&m_o_rb, (const char *)msg, (ring_buffer_size_t)size);
}


/** Returns >= 256 if there is nothing to be read;
 * otherwise returns a uint8_t of what is next to be read.
 */
uint16_t serial_read() {
  uint8_t c;

  if (!ring_buffer_dequeue(&s_i_rb, (char *)&c)) {
    return 256;
  }
  return c;
}

void printWelcomeMessage(void) {
  serial_transmit((uint8_t *)"\r\n\r\n", strlen("\r\n\r\n"));
  serial_transmit((uint8_t *)">>>", 3);
  serial_transmit((uint8_t *)test_fast_string, tfs_len);
  serial_transmit((uint8_t *)"<<<\r\n", 5);
  serial_transmit((uint8_t *)WELCOME_MSG, strlen(WELCOME_MSG));
  serial_transmit((uint8_t *)MAIN_MENU, strlen(MAIN_MENU));
}


static int prompted = 0;

/** Prompts for input for each input.
 * Returns the ASCII code received, or 0 if no character received.
 * Yes, that makes it ambiguous on receiving an ASCII NUL.
 */
uint8_t read_user_input(void) {
  uint16_t c;

  if (!prompted) {
    serial_transmit((uint8_t*)PROMPT, strlen(PROMPT));
    prompted = 1;
  }

  c = serial_read();

  // No character waiting for input
  if (c >= 0x100) {
    return 0;
  }

  prompted = 0;
  return (uint8_t)c;
}

/** Midi note sending state machine.
 * IDLE until asked to send a note on.
 * Then WAITING until the appropriate tick.
 * Then will SEND a note off, and return to IDLE.
 */

typedef enum MidiState {
  MIDI_IDLE, MIDI_WAITING
} midi_state_t;

midi_state_t midi_state = MIDI_IDLE;
uint32_t midi_wait_until;
uint8_t note_to_turn_off;
const uint32_t midi_on_off_interval = 100; // milliseconds

/** Call regularly to handle future MIDI events
 * according to our state machine.
 */
void check_midi() {
  // Do we have anything to do?
  if (midi_state == MIDI_IDLE) {
    return;
  }
  // Have we waited long enough?
  if (HAL_GetTick() < midi_wait_until) {
    return;
  }

  // We're done waiting - send the note off and return to idle
  midi_state = MIDI_IDLE;
  NOTE_OFF[1] = note_to_turn_off & 0x7F;
  midi_transmit((uint8_t *)NOTE_OFF, 3);
}

/** If the MIDI state machine is idle,
 * initiate a note on, and start the state
 * machine waiting to send the note off.
 * Returns 0 if we were not idle, or 1 if we initiated a note.
 */
int initiate_midi_note_on_off(uint8_t note_number) {
  // Are we already sending a note?
  if (midi_state != MIDI_IDLE) {
    // TODO: Record a count of busy state machine events?
    return 0;
  }

  // FIXME: Susceptible to 1000Hz tick wrap-around. In 40-odd days. Don't care.
  midi_wait_until = HAL_GetTick() + midi_on_off_interval;
  midi_state = MIDI_WAITING;
  note_to_turn_off = note_number;
  NOTE_ON[1] = note_number & 0x7F;
  midi_transmit((uint8_t *)NOTE_ON, 3);
  return 1;
}

/** intentionally overflow the stack to see what happens */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winfinite-recursion"
void stack_overflow_test(void) {
  stack_overflow_test();
}
#pragma GCC diagnostic pop

/** Allocate memory until we get to ENOMEM */
void alloc_test() {
  char msg[40];
  uint32_t t;

  void *m;
  size_t amount = 10240;

  do {
    m = malloc(amount);
    if (NULL == m) {
      snprintf(msg, sizeof(msg) - 1, "OOM: %d; amt: %u\r\n", errno, amount);
      amount >>= 1;
    } else {
      snprintf(msg, sizeof(msg) - 1, "Addr: %08lX; amt: %u\r\n", (uint32_t)m, amount);
    }
    serial_transmit((uint8_t *)msg, strlen(msg));

    // Send I/O and delay before doing this again
    t = HAL_GetTick();
    do {
      check_io();
    } while (HAL_GetTick() < t + 100);
  } while (m != NULL || amount > 0);
}


/** Plays the current tone for a second */
void sound_tone() {
  volatile uint32_t temp = 0;
  uint32_t start_tick = HAL_GetTick();
  const uint32_t end_tick = start_tick + 1000;
  int16_t next_sample;
  HAL_StatusTypeDef result;

  do {
    next_sample = tonegen_next_sample(&tonegen1);
    result = HAL_I2S_Transmit(&hi2s3, &next_sample, 1, 2);
    temp++;
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_14);

  } while (HAL_GetTick() < end_tick);

  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, 0);
}


/** Interprets numbers as menu options.
 * Interprets letters as notes to send via MIDI.
 * Ignores the rest.
 * Returns 0 on no valid input.
 * Returns 1 on processed input.
 * Returns 2 if we should re-display the menu.
 */
uint8_t process_user_input(uint8_t opt) {
  int l;

  if (opt == 0) {
    return 0;
  }

  char msg[40];

  serial_transmit(&opt, 1);

  switch (opt) {
  case '1':
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);
    break;
  case '2':
    snprintf(msg, sizeof(msg) - 1, "\r\nUSER BUTTON status: %s",
              HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) != GPIO_PIN_RESET ? "PRESSED" : "RELEASED");
    serial_transmit((uint8_t*)msg, strlen(msg));
    break;
  case '3':
    initiate_midi_note_on_off(0x40);
    break;
  case '4':
    snprintf(msg, sizeof(msg) - 1, "\r\nUA3I: %lu, ORE: %lu, MIDI_ORE: %lu, ",
              usart3_interrupts, overrun_errors, midi_overrun_errors);
    serial_transmit((uint8_t*)msg, strlen(msg));
    snprintf(msg, sizeof(msg) - 1, "LPT: %lu\r\n", loops_per_tick);
    serial_transmit((uint8_t*)msg, strlen(msg));
    break;
  case '5':
    l = snprintf(msg, sizeof(msg) - 1, "Tone: %d\r\n", tonegen_next_sample(&tonegen1));
    serial_transmit((uint8_t*)msg, l);
    break;
  case '6':
    sound_tone();
    break;
  case '(':
    // Use all memory
    alloc_test();
    break;
  case ')':
    stack_overflow_test();
    break;
  case '~':
  case '`':
    // Re-print the options
    return 2;
  case 'a':
    initiate_midi_note_on_off(60); // Middle C
    break;
  case 's':
    initiate_midi_note_on_off(62); // Middle D
    break;
  case 'd':
    initiate_midi_note_on_off(64); // Middle E
    break;
  case 'f':
    initiate_midi_note_on_off(65); // Middle F
    break;
  case 'g':
    initiate_midi_note_on_off(67); // Middle G
    break;
  case 'h':
    initiate_midi_note_on_off(69); // Middle A
    break;
  case 'j':
    initiate_midi_note_on_off(71); // Middle B
    break;
  case 'k':
    initiate_midi_note_on_off(72); // High C
    break;
  default:
    return 0;
  }

  return 1;
}

/** Reads from our MIDI input ring buffer.
 * Returns 0-255 when byte received.
 * Returns 256+ when no byte received.
 */
uint16_t read_midi(void) {
  uint8_t c;

  if (!ring_buffer_dequeue(&m_i_rb, (char *)&c)) {
    // No input available
    return (uint16_t)0x100U;
  }
  return (uint16_t)c;
}

/**
 * Processes a received MIDI byte.
 * For now, just print it (which will certainly lead to overrun).
 */
void process_midi(uint8_t midi_byte) {
  char msg[64];
  midi_message mm;

  // Don't print every byte anymore
  /*
  snprintf(msg, sizeof(msg) - 1, "\r\nMIDI byte: %02X\r\n", midi_byte);
  serial_transmit((uint8_t *)msg, strlen(msg));
  */

  if (midi_stream_receive(&midi_stream_0, midi_byte, &mm)) {
    // Received a full MIDI message
    midi_snprintf(msg, sizeof(msg) - 1, &mm);
    serial_transmit((uint8_t *)msg, strlen(msg));
    serial_transmit((uint8_t *)"\r\n", 2);
  }
}


void test_i2s() {
  volatile uint32_t temp = 0;

  // __HAL_RCC_I2S_CONFIG(RCC_I2SCLKSOURCE_PLLI2S); // RCC_I2SCLKSOURCE_EXT); RCC_I2SCLKSOURCE_PLLI2S
  // HAL_I2SEx

  while (1) {
    // Test I2S
    HAL_StatusTypeDef result;
    result = HAL_I2S_Transmit(&hi2s3, triangle_wave, sizeof(triangle_wave) / sizeof(triangle_wave[0]), 250);
    temp++;
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);
  }
}

void realmain() {
  uint16_t opt = 0;
  uint32_t last_overrun_errors = overrun_errors;
  uint32_t last_usart3_interrupts = usart3_interrupts;
  char msg[36];
  uint16_t midi_in = 0;
  uint32_t counter = 0;
  const uint32_t end_counter = 1000000;
  uint8_t processed_input;
  uint32_t cur_tick;
  uint32_t last_tick = HAL_GetTick();
  uint32_t tick_counter = 0;

  // test_i2s();

  init_ring_buffers();
  init_midi_buffers();
  tonegen_init(&tonegen1, 32000);
  tonegen_set(&tonegen1,  1000, 32000);

  printMessage:
  printWelcomeMessage();

  while (1) {
    // Always check for I/O available for read/write
    check_io();

    // Handle our MIDI state machine
    check_midi();

    // Now do everything in an entirely non-blocking way
    opt = read_user_input();
    processed_input = process_user_input(opt);

    // Put a dot every N (million) times through this loop
    counter++;
    if (counter >= end_counter) {
      counter = 0;
      serial_transmit((uint8_t *)".", 1);
    }

    // count how many times through the loop we get per tick
    cur_tick = HAL_GetTick();
    if (cur_tick != last_tick) {
      // As of this version of my code, this is usually 114 loops per tick,
      // which means about 114 kHz through this loop. Not bad.
      loops_per_tick = tick_counter;
      tick_counter = 0;
      last_tick = cur_tick;
    } else {
      tick_counter++;
    }

    midi_in = read_midi();
    if (midi_in <= 255) {
      process_midi((uint8_t)midi_in);
    }

    if (overrun_errors != last_overrun_errors) {
      snprintf(msg, sizeof(msg) - 1, "\r\nORE: %lu\r\n", overrun_errors);
      last_overrun_errors = overrun_errors;
      serial_transmit((uint8_t *)msg, strlen(msg));
    }
    if (usart3_interrupts != last_usart3_interrupts) {
      snprintf(msg, sizeof(msg) - 1, "\r\nUA3I: %lu\r\n", usart3_interrupts);
      last_usart3_interrupts = usart3_interrupts;
      serial_transmit((uint8_t *)msg, strlen(msg));
    }

    if (processed_input == 2) {
      goto printMessage;
    }
  }
} // realmain()



////////////////////////////////////////////////////////////////////////////////////////
// Callbacks


void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
  // We just want to clear an overrun error and acknowledge it happened.
  // SEE: https://electronics.stackexchange.com/questions/376104/smt32-hal-uart-crash-on-possible-overrun
  // SEE: https://github.com/micropython/micropython/issues/3375


  if (huart == &huart3) {
    // Serial terminal via ST-Link
    usart3_interrupts++;

    // The earlier code will have set the HAL_UART_ERROR_ORE flag IF an OverRunError happened.
    // See the code commented: UART Over-Run interrupt occurred

    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
      uart_error_callbacks++;
    }

  } else if (huart == &huart6) {
    // MIDI
    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
      midi_overrun_errors++;
    }
    // midi_overrun_errors++;
  }
  // Re-enable the interrupts (not sure if this is necessary)
  // This did not work when in the "if" above (it never got invoked).
  __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
}

